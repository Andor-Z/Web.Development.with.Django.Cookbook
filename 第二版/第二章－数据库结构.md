# Chapter 2. Database Structure 第二张数据库结构

In this chapter, we will cover the following topics:  

<<<<<<< HEAD
本章，我们覆盖了以下主题：  
=======
本章，我们将讨论以下话题：  
>>>>>>> origin/master

- Using model mixins
- Creating a model mixin with URL-related methods
- Creating a model mixin to handle creation and modification dates
- Creating a model mixin to take care of meta tags
- Creating a model mixin to handle generic relations
- Handling multilingual fields
- Using migrations
- Switching from South migrations to Django migrations
- Changing a foreign key to the many-to-many field

<<<<<<< HEAD
- 使用模型mixin
- 创建包含相对URL方法的模型mixin
- 创建可以处理日期建立和修改的模型mixin
- 创建一个模型mixin以处理元标签
- 创刊一个模型mixin一处理通用关系
- 处理对语言字段
- 从South migrations切换到Django migrations
- 将一个外键变更为多对多字段
=======
- 使用模型Mixin
- 创建一个拥有相对URL方法的模型Mixin
- 创建一个能够处理日期的创建和修改的模型Minix
- 创建一个可以处理元标签的模型Minxin
- 创建一个处理通用关系的模型Mixin
- 处理多语言字段
- 应用迁移
- 从South的migration切换到Django的migration
- 改变一个关联到多对多字段到外键
>>>>>>> origin/master

## Introduction 引言

When you start a new app, the first thing to do is create the models that represent your database structure. We are assuming that you have previously created Django apps or at least, you have read and understood the official Django tutorial. In this chapter, we will see a few interesting techniques that make your database structure consistent throughout different apps in your project. Then, we will see how to create custom model fields in order to handle internationalization of your data in the database. At the end of the chapter, we will see how to use migrations to change your database structure in the process of development.  

<<<<<<< HEAD
当你开始编写一个新应用时，要做的第一件事就是创建代表数据库结构的模型。我们假设你在之前你已经创建了Django应用，至少你阅读过并理解了Django官方教程。本章，我们可以看到一些有趣的能让你项目中的不同应用保持数据库结构一致性的技术。然后我们可以看到如何创建自定义模型字段以便处理数据库中的国际化数据。在章节的最后，我们可以看到如何使用迁移在开发阶段改变数据库结构。  

## Using model mixins 使用模型mixin

In object-oriented languages, such as Python, a mixin class can be viewed as an interface with implemented features. When a model extends a mixin, it implements the interface and includes all its fields, properties, and methods. Mixins in Django models can be used when you want to reuse the generic functionalities in different models multiple times.  

在面相对象语言中，比如Python，mixin类可以看作是一个实现功能的借口。当模型扩展了一个mixin，它便实现了接口，包括所有mixin的全部字段，属性，和方法。Django模型的Mixin可以用在当你想要在不同的模型中多次重复使用通用功能时。  

### Getting ready

First, you will need to create reusable mixins. Some typical examples of mixins are given later in this chapter. A good place to keep your model mixins is in the `utils` module.  

首先，你需要创建可重复使用的mixin。一些mixin的典型例子会在本章稍后给出。一个存放模型mixin的好地方就是`utils`模块。  

>### Tip
>If you create a reusable app that you will share with others, keep the model mixins in the reusable app, for example, in the base.py file.  

>### 提示
>如果你要创建一个和其他人分享的可重复使用的应用，请将模型mixin放到可重复使用的应用中，例如，base.py
=======
当你创建一个新应用时，要做的第一件事就是创建表现数据库结构到模型。现在，我们假设你已经创建了Django应用，至少你读过并理解了Django的官方入门指南。本章，我们会看到一些有意思的，能够让数据库结构在项目的不同应用中保持一致性的技术。然后，我们可以看到创建自定义模型以处理数据库中数据的国际化。本章最后，我们可以看到在开发过程中如何使用migraiton来改变数据库结构。  

## Using model mixins 使用模型Mixin

In object-oriented languages, such as Python, a mixin class can be viewed as an interface with implemented features. When a model extends a mixin, it implements the interface and includes all its fields, properties, and methods. Mixins in Django models can be used when you want to reuse the generic functionalities in different models multiple times.  

在像Python面向对象语言中，minxin类可以看作是一个拥有已实现功能的接口。当模型扩展为mixin，它可以实现接口以及所有自身所有的字段、特性、和方法。Django模型的Mixin可以多次地在不同的模型中重复使用通用功能。  

### Getting ready 准备工作

First, you will need to create reusable mixins. Some typical examples of mixins are given later in this chapter. A good place to keep your model mixins is in the `utils` module.  

首先，你需要创建可被重复使用的mixin。一些典型的mixin例子会在本章后面给出。

>### Tip 提示
>If you create a reusable app that you will share with others, keep the model mixins in the reusable app, for example, in the base.py file.  

如果你创建一个和其他人分享的重复使用的应用，可以将模型mixin放到重复使用的应用中，比如，放到文件base.py。  

### How to do it… 具体怎么办
>>>>>>> origin/master

### How to do it…
Open the models.py file of any Django app, where you want to use the mixins and type the following code:  

<<<<<<< HEAD
打开任意一个Django应用中的models.py文件，在这个文件中你需要使用mixin，并输入以下代码：  
=======
代开任意一个Django应用的models.py，在文件中你可以使用mixin，然后输入一下代码：  
>>>>>>> origin/master

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import python_2_unicode_compatible
from utils.models import UrlMixin
from utils.models import CreationModificationMixin
from utils.models import MetaTagsMixin


@python_2_unicode_compatible
class Idea(UrlMixin, CreationModificationMixin, MetaTagsMixin):
  title = models.CharField(_("Title"), max_length=200)
  content = models.TextField(_("Content"))

  class Meta:
    verbose_name = _("Idea")
    verbose_name_plural = _("Ideas")

  def __str__(self):
    return self.title
```

### How it works… 实现原理
Django model inheritance supports three types of inheritance: abstract base classes, multi-table inheritance, and proxy models. Model mixins are abstract model classes with specified fields, properties, and methods. When you create a model such as Idea, as shown in the preceding example, it inherits all the features from UrlMixin, CreationModificationMixin, and MetaTagsMixin. All the fields of the abstract classes are saved in the same database table as the fields of the extending model. In the following recipes, you will learn how to define your model mixins.  

<<<<<<< HEAD
Django的模型支持三种类型的继承：抽象基类，多表继承，以及代理模型。模型mixin是拥有特定字段、属性和方法的抽象模型类。

Note that we are using the @python_2_unicode_compatible decorator for our Idea model. As you might remember from the Making your code compatible with both Python 2.7 and Python 3 recipe in Chapter 1, Getting Started with Django 1.8, it's purpose is to make the __str__() method compatible with Unicode for both the following Python versions: 2.7 and 3.  
=======
Django模型即成支持三种类型的继承：抽象基类，多表继承，以及代理模型。模型Mixin是指定了字段、特性和方法的抽象基类。当你依照这个观念来创建模型，就像在之前例子中那样，它降从UrlMixin、CreationModificationMixin, 和 MetaTagsMixin继承所有的功能。抽象基类的所有字段都保存在相同数据库表中，并作为扩展模型的字段。在下面的做法中，你会学习到如何定义自己的模型mixin。  
>>>>>>> origin/master

Note that we are using the `@python_2_unicode_compatible` decorator for our Idea model. As you might remember from the Making your code compatible with both Python 2.7 and Python 3 recipe in Chapter 1, Getting Started with Django 1.8, it's purpose is to make the `__str__()` method compatible with Unicode for both the following Python versions: 2.7 and 3.  

注意我们对Idea模型应用了装饰器`@python_2_unicode_compatible`。

### There's more… 更多内容

To learn more about the different types of model inheritance, refer to the official Django documentation available at https://docs.djangoproject.com/en/1.8/topics/db/models/#model-inheritance.  

### See also 参见

- The Making your code compatible with both Python 2.7 and Python 3 recipe in Chapter 1, Getting Started with Django 1.8
- The Creating a model mixin with URL-related methods recipe
- The Creating a model mixin to handle creation and modification dates recipe
- The Creating a model mixin to take care of meta tags recipe

## Creating a model mixin with URL-related methods 创建一个拥有相对URL方法对模型mixin
For every model that has its own page, it is good practice to define the `get_absolute_url()` method. This method can be used in templates and also in the Django admin site to preview the saved object. However, `get_absolute_url()` is ambiguous as it returns the URL path instead of the full URL. In this recipe, we will see how to create a model mixin that allows you to define either the URL path or the full URL by default, generate the other out of the box, and take care of the `get_absolute_url()` method that is being set.  

如果每个模型都要拥有自己的页面，那么最好的解决办法是定义`get_absolute_url()`方法。改方法可以在模板中使用，也可以用在Django的admin站点中预览保存的对象。不过，`get_absolute_url()`返回是模棱两可的，因为它返回的是URL路径，而不是完整的URL。在这个做法中，我们可以看如何创建一个允许你定义URL路径或者是定义完整URL的模型mixin，

### Getting ready 准备工作
If you haven't done it yet, create the utils package to save your mixins. Then, create the models.py file in the utils package (alternatively, if you create a reusable app, put the mixins in the base.py file in your app).  



### How to do it… 

Execute the following steps one by one:  
一步步地执行下面的步骤：  

1. Add the following content to the models.py file of your utils package:  

添加以下内容到utils包中的models.py文件：  

```python
# utils/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
import urlparse
from django.db import models
from django.contrib.sites.models import Site
from django.conf import settings

class UrlMixin(models.Model):
    """
    A replacement for get_absolute_url Models extending this mixin should have 
    either get_url or get_url_path implemented.
    """
    class Meta:
        abstract = True

    def get_url(self):
        if hasattr(self.get_url_path, "dont_recurse"):
            raise NotImplementedError
        try:
            path = self.get_url_path()
        except NotImplementedError:
            raise
        website_url = getattr(
            settings, "DEFAULT_WEBSITE_URL", "http://127.0.0.1:8000"
        )
        return website_url + path

    get_url.dont_recurse = True

    def get_url_path(self):
        if hasattr(self.get_url, "dont_recurse"):
            raise NotImplementedError
        try:
            url = self.get_url()
        except NotImplementedError:
            raise
        bits = urlparse.urlparse(url)
        return urlparse.urlunparse(("", "") + bits[2:])

    get_url_path.dont_recurse = True

    def get_absolute_url(self):
        return self.get_url_path()
```

2. To use the mixin in your app, import it from the utils package, inherit the mixin in your model class, and define the get_url_path() method as follows:  

```python
# demo_app/models.py
# -*- coding: UTF-8 -*-
from __future__ import unicode_literals
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.urlresolvers import reverse
from django.utils.encoding import \
    python_2_unicode_compatible

from utils.models import UrlMixin


@python_2_unicode_compatible
class Idea(UrlMixin):
    title = models.CharField(_("Title"), max_length=200)
    # ...
    get_url_path(self):
        return reverse("idea_details", kwargs={
            "idea_id": str(self.pk),
        })
```

3. If you check this code in the staging or production environment or run a local server with a different IP or port than the defaults, set DEFAULT_WEBSITE_URL in your local settings (without the trailing slash), as follows:  

如果你是在过渡环境或者是生成环境中检验该代码，又或者是运行一个使用了不同于默认的IP、端口，那么你可以在本地的配置中设置DEFAULT_WEBSITE_URL（没有反斜杠），一如下面所示：  

```python
# settings.py
# …
DEFAULT_WEBSITE_URL = "http://www.example.com"
```

